<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>name</key>
        <string>Get Snippet</string>
        <key>uuid</key>
        <string>D9E343A9-A23D-4601-85C4-BB463A55FE78</string>
        <key>input</key>
        <string>none</string>
        <key>output</key>
        <string>insertAsSnippet</string>
        <key>command</key>
        <string>#!/usr/bin/env ruby -w
require &quot;xmlrpc/client&quot;
require &quot;cgi&quot;
require ENV[&apos;TM_SUPPORT_PATH&apos;] + &quot;/lib/exit_codes.rb&quot;
require ENV[&apos;TM_SUPPORT_PATH&apos;] + &quot;/lib/escape.rb&quot;

COCOA_DIALOG = ENV[&apos;TM_SUPPORT_PATH&apos;] + &apos;/bin/CocoaDialog&apos;
unless File.exists?(COCOA_DIALOG)
  print &quot;Error: wxCocoaDialog not found&quot;
  TextMate.exit_show_tool_tip
end

# Need to hardcode the variable until we get
# environment variables in e.
API_KEY = &quot;YOUR_API_KEY_HERE&quot; 
server = XMLRPC::Client.new( &quot;snipplr.com&quot;, &quot;/xml-rpc.php&quot;)

if 0 == server.call(&quot;user.checkkey&quot;, API_KEY)
  puts &quot;#{API_KEY} was not accepted as a valid API Key&quot;
  TextMate.exit_show_tool_tip
end

begin
  result = server.call(&quot;snippet.list&quot;, API_KEY)
  result_list = &quot;&quot;
  result.each { |row| result_list += &quot;&apos;#{row[&apos;id&apos;]} : #{row[&apos;title&apos;]}&apos; &quot; }
  
  res=%x(&quot;#{COCOA_DIALOG}&quot; dropdown \
      --title &quot;Retrieve Snippet&quot; \
      --string-output \
      --text &quot;You have #{result.length} Snipplr entries stored under this API Key.&quot; \
      --items #{result_list} \
      --button1 &apos;Retreive&apos; --button2 &apos;Cancel&apos;)
  button, item = res.split
  case button
    when &apos;Retreive&apos;
      $snippet = server.call(&quot;snippet.get&quot;, item)
    when &apos;Cancel&apos;
      puts &quot;Snippet retreival cancelled.&quot;
      exit
  end 
  puts e_sn(CGI::unescapeHTML($snippet[&apos;source&apos;]))
  
rescue XMLRPC::FaultException =&gt; err
  if err.faultString =~ /No snippets found/ 
    print &quot;You don&apos;t have any snippets yet!&quot; 
  else 
    print &quot;Error: &quot; + err.faultCode.to_s + &quot;, &quot; + err.faultString
  end
  TextMate.exit_show_tool_tip
rescue
  print &quot;Error: #{$!}&quot;
  TextMate.exit_show_tool_tip
end</string>
        <key>keyEquivalent</key>
        <string>~p</string>
    </dict>
</plist>
