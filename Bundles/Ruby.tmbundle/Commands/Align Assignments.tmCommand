<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>name</key>
        <string>Align Assignments</string>
        <key>uuid</key>
        <string>78D157D6-CA1A-44C4-8850-6C877F162FC9</string>
        <key>input</key>
        <string>selection</string>
        <key>output</key>
        <string>replaceSelectedText</string>
        <key>command</key>
        <string>#!/usr/bin/env ruby&#x0A;#&#x0A;# Assignment block tidier, version 0.1.1&#x0A;#&#x0A;# Attribution Notice:&#x0A;# Original version Copyright Chris Poirier 2006.&#x0A;# Licensed under the Academic Free License version 3.0.&#x0A;#&#x0A;# Modifications by Geoff Cheshire &lt;gcheshire@gmail.com&gt; to&#x0A;# recognize Ruby hash assignments. (2007-02-14)&#x0A;#&#x0A;# Per the license, use of this script is ENTIRELY at your own risk.&#x0A;# See the license for full details (they override anything I&apos;ve &#x0A;# said here).&#x0A;&#x0A;lines = STDIN.readlines()&#x0A;selected_text = ENV.member?(&quot;TM_SELECTED_TEXT&quot;)&#x0A;&#x0A;relevant_line_pattern = /^[^=]+=/&#x0A;column_search_pattern = /[\t ]*=/&#x0A;&#x0A;&#x0A;#&#x0A;# If called on a selection, every assignment statement&#x0A;# is in the block.  If called on the document, we start on the &#x0A;# current line and look up and down for the start and end of the&#x0A;# block.&#x0A;&#x0A;if selected_text then&#x0A;   block_top    = 1&#x0A;   block_bottom = lines.length&#x0A;else&#x0A; &#x0A;   #&#x0A;   # We start looking on the current line.  However, if the&#x0A;   # current line doesn&apos;t match the pattern, we may be just&#x0A;   # after or just before a block, and we should check.  If&#x0A;   # neither, we are done.&#x0A;&#x0A;   start_on      = ENV[&quot;TM_LINE_NUMBER&quot;].to_i&#x0A;   block_top     = lines.length + 1&#x0A;   block_bottom  = 0&#x0A;   search_top    = 1&#x0A;   search_bottom = lines.length&#x0A;   search_failed = false&#x0A;&#x0A;   if lines[start_on - 1] !~ relevant_line_pattern then&#x0A;      if lines[start_on - 2] =~ relevant_line_pattern then&#x0A;         search_bottom = start_on = start_on - 1&#x0A;      elsif lines[start_on] =~ relevant_line_pattern then&#x0A;         search_top = start_on = start_on&#x0A;      else&#x0A;         search_failed = true&#x0A;      end &#x0A;   end&#x0A;&#x0A;   #&#x0A;   # Now with the search boundaries set, start looking for&#x0A;   # the block top and bottom.&#x0A;   &#x0A;   unless search_failed&#x0A;      start_on.downto(search_top) do |number|&#x0A;         if lines[number-1] =~ relevant_line_pattern then&#x0A;            block_top = number&#x0A;         else&#x0A;            break&#x0A;         end&#x0A;      end&#x0A;      &#x0A;      start_on.upto(search_bottom) do |number|&#x0A;         if lines[number-1] =~ relevant_line_pattern then&#x0A;            block_bottom = number&#x0A;         else&#x0A;            break&#x0A;         end&#x0A;      end&#x0A;   end&#x0A;end&#x0A;&#x0A;&#x0A;#&#x0A;# Now, iterate over the block and find the best column number&#x0A;# for the = sign.  The pattern will tell us the position of the&#x0A;# first bit of whitespace before the equal sign.  We put the&#x0A;# equals sign to the right of the furthest-right one.  Note that&#x0A;# we cannot assume every line in the block is relevant.&#x0A;&#x0A;best_column = 0&#x0A;block_top.upto(block_bottom) do |number|&#x0A;   line = lines[number - 1]&#x0A;   if line =~ relevant_line_pattern then&#x0A;      m = column_search_pattern.match(line)&#x0A;      best_column = m.begin(0) if m.begin(0) &gt; best_column&#x0A;   end&#x0A;end&#x0A;&#x0A;   &#x0A;#&#x0A;# Reformat the block.  Again, we cannot assume all lines in the &#x0A;# block are relevant.&#x0A;&#x0A;block_top.upto(block_bottom) do |number|&#x0A;  if lines[number-1] =~ relevant_line_pattern then&#x0A;    before, after = lines[number-1].split(/[\t ]*=[\t ]*/, 2)&#x0A;    if after =~ /^&gt;/ then # Oops -- we&apos;re dealing with a hash assignment&#x0A;      lines[number-1] = before.ljust(best_column) + &quot; =&gt; &quot; + after.gsub(/^&gt;/, &apos;&apos;)&#x0A;    else&#x0A;      lines[number-1] = before.ljust(best_column) + &quot; = &quot; + after&#x0A;    end&#x0A;  end&#x0A;end&#x0A;&#x0A;&#x0A;#&#x0A;# Output the replacement text&#x0A;&#x0A;lines.each do |line|&#x0A;   puts line&#x0A;end</string>
        <key>keyEquivalent</key>
        <string>~@]</string>
        <key>scope</key>
        <string>source.ruby</string>
    </dict>
</plist>
